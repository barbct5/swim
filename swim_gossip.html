<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module swim_gossip</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module swim_gossip</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module is responsible for the failure detection mechanism of the   
SWIM protocol.
<p>Copyright © 2015</p>

<p><b>Version:</b> Jul 2 2015 19:35:41</p>

<h2><a name="description">Description</a></h2><p>This module is responsible for the failure detection mechanism of the   
SWIM protocol.</p>
  
   When starting the gossip process, we require the Ipv4 address and port number
   to send and receive messages from other peers in the gossip group. We can
   also provide configuration parameters to tune the underlying protocol.
   The parameters we expose are:
   <dl>
    <dt><code>{protocol_period, pos_integer()}</code></dt>
    <dd>The time, in milliseconds, between protocol intervals. This value is
   referred to as <b><code>T'</code></b> in the SWIM papaer. The
   paper notes that the protocol period has to be at least 3 times the
   estimated round-trip time for a message. The protocol period is not
   adjustable after the peer is started.</dd>
    <dt><code>{ack_timeout, pos_integer()}</code></dt>
    <dd>The time, in milliseconds, to wait for
   an ACK in response to a PING. The ACK timeout must be less than the protocol
   period. The ACK timeout should be based on the latency distribution on your
   network. Good choices may be the average round-trip time or the 99th
   percentile.</dd>
    <dt><code>{ack_proxies, pos_integer()}</code></dt>
    <dd>The number of peers to send indirect
   probes via the PING-REQ message. This value is referred to as
   <b><code>k</code></b> in the SWIM paper.</dd>
    <dt><code>{suspicion, pos_integer()}</code></dt>
    <dd>A scaling factor for the number of
   protocol periods we wait for a suspected member to refute our claim. See
   <a href="swim_membership.html"><code>swim_membership</code></a> for more information.</dd>
    <dt><code>{retransmit, pos_integer()}</code></dt>
    <dd>A scaling factor for the number of times
   we broadcast membership updates to peers in the gossip group. This value
   is referred to as <b><code>λ</code></b> in the SWIM paper.
   See <a href="swim_broadcasts.html"><code>swim_broadcasts</code></a> for more information.</dd>
    <dt><code>{seeds, [member()]}</code></dt>
    <dd>A list of members in an existing gossip group.
   When we start the local peer we attempt to join an existing
   group via the provided seeds. To start a new gossip group, we can provide 0
   seed members.</dd>
   </dl>
  
   <h3><a name="SWIM_Failure_Detector">SWIM Failure Detector</a></h3><p>
   During each protocol period defined by
   <code>protocol_period</code>, a random member is selected from the local
   peer's membership list and a PING message sent to it. When a peer
   is first started the membership list contains the <code>seeds</code>. The
   local peer then waits for a reply ACK from the target of the
   PING. If an ACK is not recieved witin the <code>ack_timeout</code> period,
   the local peer will indirectly probe the target. The local peer
   selects <code>ack_proxies</code> members at random, excluding the target of   
the original PING, and sends each a PING-REQ message. Each of   
these members in turn, on receiving a PING-REQ, sends a PING to   
the original PING target and forwards the ACK back to the local   
peer. If the proxies do not receive an ACK, the ACK timeout is   
ignored and they continue with their business. At the end of the   
protcol period the local peer checks if it has received any ACKs   
either directly from it's original target or indirectly through   
one of the proxies. If not, it declares the target suspicious in it's   
local membership list and broadcasts the update to the rest of the   
gossip group.</p>
  
   The data contained in each message of the protcol is tagged with
   unique sequence number of the protocol period at the
   initiator. ACKs will contain the same sequence number contained in
   the original PING or PING-REQ. Upon receiving an ACK, the
   initiator can then distiguish between ACKs sent in response to a
   PING or PING-REQ during the current protocol period or ACKs sent
   in response to a PING from a previous protocol period where the
   target has already been marked as suspicious. For more information
   on the Supicious mechanism, see <a href="swim_membership.html"><code>swim_membership</code></a>.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-gossip_opt">gossip_opt()</a></h3>
<p><tt>gossip_opt() = {protocol_period, pos_integer()} | {ack_timeout, pos_integer()} | {ack_proxies, pos_integer()} | {retransmit, pos_integer()}</tt></p>


<h3 class="typedecl"><a name="type-swim_opt">swim_opt()</a></h3>
<p><tt>swim_opt() = <a href="#type-gossip_opt">gossip_opt()</a> | {keys, [<a href="#type-key">key()</a>]} | <a href="swim_membership.html#type-membership_opt">swim_membership:membership_opt()</a></tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#close-1">close/1</a></td><td>Closes the gossip peer without announcing leaving to the rest of
       members.</td></tr>
<tr><td valign="top"><a href="#gossip-2">gossip/2</a></td><td>Gossip an arbitrary term to currently known peers.</td></tr>
<tr><td valign="top"><a href="#leave-1">leave/1</a></td><td>Closes the gossip peer after announcing leaving to the rest of
       members.</td></tr>
<tr><td valign="top"><a href="#members-1">members/1</a></td><td>Get all the members known to the gossip peer including itself.</td></tr>
<tr><td valign="top"><a href="#members_with_status-1">members_with_status/1</a></td><td>Get all the members known to the gossip peer including itself along with
       the locally observed status of the member.</td></tr>
<tr><td valign="top"><a href="#rotate_keys-2">rotate_keys/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#start_link-4">start_link/4</a></td><td>Starts the Gossip process for this Node.</td></tr>
<tr><td valign="top"><a href="#stats-1">stats/1</a></td><td>Retreive protocol stats.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="close-1">close/1</a></h3>
<div class="spec">
<p><tt>close(Name::atom()) -&gt; ok</tt><br></p>
</div><p>Closes the gossip peer without announcing leaving to the rest of
       members.</p>

<h3 class="function"><a name="gossip-2">gossip/2</a></h3>
<div class="spec">
<p><tt>gossip(Name::atom(), Event::term()) -&gt; ok</tt><br></p>
</div><p><p>Gossip an arbitrary term to currently known peers.</p>
 
  Gossiping a term to the rest of the peers piggybacks on the same protocol
  used for disseminating membership changes. Terms provided are subject to size
  limitations defined in <a href="swim_messages.html#event_size_limit-0"><code>swim_messages:event_size_limit/0</code></a>.</p>

<h3 class="function"><a name="leave-1">leave/1</a></h3>
<div class="spec">
<p><tt>leave(Name::atom()) -&gt; ok</tt><br></p>
</div><p>Closes the gossip peer after announcing leaving to the rest of
       members.</p>

<h3 class="function"><a name="members-1">members/1</a></h3>
<div class="spec">
<p><tt>members(Name::atom()) -&gt; [<a href="#type-member">member()</a>]</tt><br></p>
</div><p>Get all the members known to the gossip peer including itself. Members
       include both alive and suspicious members.</p>

<h3 class="function"><a name="members_with_status-1">members_with_status/1</a></h3>
<div class="spec">
<p><tt>members_with_status(Name::atom()) -&gt; [{<a href="#type-member">member()</a>, <a href="#type-member_status">member_status()</a>}]</tt><br></p>
</div><p>Get all the members known to the gossip peer including itself along with
       the locally observed status of the member.</p>

<h3 class="function"><a name="rotate_keys-2">rotate_keys/2</a></h3>
<div class="spec">
<p><tt>rotate_keys(Name::atom(), Key::<a href="#type-key">key()</a>) -&gt; ok</tt><br></p>
</div>

<h3 class="function"><a name="start_link-4">start_link/4</a></h3>
<div class="spec">
<p><tt>start_link(Name::atom(), ListenIp::<a href="inet.html#type-ip_address">inet:ip_address()</a>, ListenPort::<a href="inet.html#type-port_number">inet:port_number()</a>, Opts::[<a href="#type-gossip_opt">gossip_opt()</a>]) -&gt; {ok, pid()} | {error, term()}</tt><br></p>
</div><p>Starts the Gossip process for this Node.</p>

<h3 class="function"><a name="stats-1">stats/1</a></h3>
<div class="spec">
<p><tt>stats(Name::atom()) -&gt; list()</tt><br></p>
</div><p>Retreive protocol stats. Stats included <a href="inet.html#getstat-1"><code>inet:getstat/1</code></a>.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Jul 2 2015, 19:35:41.</i></p>
</body>
</html>
