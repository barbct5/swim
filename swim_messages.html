<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module swim_messages</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module swim_messages</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>This module is responsible for encoding and decoding SWIM protocol   
messages as well as encrypting and decrypting the message payloads.
<p>Copyright Â© 2015</p>

<p><b>Version:</b> Jul 2 2015 19:35:41</p>

<h2><a name="description">Description</a></h2><p>This module is responsible for encoding and decoding SWIM protocol   
messages as well as encrypting and decrypting the message payloads.</p>
  
   SWIM protocol message encodings can be found in the documentation
   coorisponding with the various encoding functions defined in this module.
   <a href="#encode_ack-3"><code>encode_ack/3</code></a>, <a href="#encode_ping-2"><code>encode_ping/2</code></a>, <a href="#encode_ping_req-2"><code>encode_ping_req/2</code></a>,
   <a href="#encode_leave-1"><code>encode_leave/1</code></a>.
   All SWIM protocol messages are prefixed with a single octet reflecting
   the protocol version of the message. The overall format of SWIM messages is:
   <table border="1">
     <tr>
       <td>1</td>
       <td>1</td>
       <td>N</td>
    </tr>
    <tr>
      <td>Version</td>
      <td>Tag</td>
      <td>Data</td>
    </tr>
   </table>
   <dl>
     <dt><strong><code>Version</code></strong></dt>
     <dd>is the protocol version the message is encoded for</dd>
     <dt><strong><code>Tag</code></strong></dt>
     <dd>indicates what type of SWIM message follows. Tag can represent ACK,
   PING, PING-REQ, or LEAVE.</dd>
   </dl>
   All SWIM messages are encrypted over the wire using AES128-CFB with an HMAC
   for authentication. See <a href="#encrypt-3"><code>encrypt/3</code></a> for more information. The
   encryption header is encoded as follows:
   <table border="1">
     <tr>
       <td>32</td>
       <td>16</td>
       <td>N</td>
     </tr>
     <tr>
       <td>HMAC</td>
       <td>IV</td>
       <td>SWIM Message</td>
     </tr>
   </table>
<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#decode-1">decode/1</a></td><td>Decodes the provided message from a binary to an Erlang Term.</td></tr>
<tr><td valign="top"><a href="#decrypt-3">decrypt/3</a></td><td>Verifies the authenticity of the payload and decrypts the ciphertext
  generated by <a href="#encrypt-3"><code>encrypt/3</code></a>.</td></tr>
<tr><td valign="top"><a href="#encode_ack-3">encode_ack/3</a></td><td>Encodes an ACK message, piggybacking membership and user events.</td></tr>
<tr><td valign="top"><a href="#encode_event-1">encode_event/1</a></td><td>Encode either a membership event or a user event.</td></tr>
<tr><td valign="top"><a href="#encode_events-1">encode_events/1</a></td><td>Encodes a list of swim events.</td></tr>
<tr><td valign="top"><a href="#encode_leave-1">encode_leave/1</a></td><td>Encodes a LEAVE message.</td></tr>
<tr><td valign="top"><a href="#encode_member-1">encode_member/1</a></td><td>Encodes a Member as the IPv4 address and port number combination.</td></tr>
<tr><td valign="top"><a href="#encode_ping-2">encode_ping/2</a></td><td>Encodes a PING message, piggybacking membership and user events.</td></tr>
<tr><td valign="top"><a href="#encode_ping_req-2">encode_ping_req/2</a></td><td>Encodes a PING-REQ message.</td></tr>
<tr><td valign="top"><a href="#encrypt-3">encrypt/3</a></td><td>Encrypts the provided plain text using the Advanced Encryption Standard
  (AES) in Galois/Counter (GCM) using the provided 32-octet Key,
  Associated Authenticated Data (AAD), and a randomly generated
  Initialization Vector (IV).</td></tr>
<tr><td valign="top"><a href="#event_size_limit-0">event_size_limit/0</a></td><td>Event size limit determines the maximum size (in octets) available to       
to piggyback membership and user events on an ACK or PING message.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="decode-1">decode/1</a></h3>
<div class="spec">
<p><tt>decode(Message::binary()) -&gt; <a href="#type-swim_message">swim_message()</a></tt><br></p>
</div><p><p>Decodes the provided message from a binary to an Erlang Term.</p>
 
  All messages are prefixed with a single octet to indicate the version of
  of the protocol. The return value is an Erlang term of the message. If the
  version is not supported or the message is malformed, an exception is thrown.</p>

<h3 class="function"><a name="decrypt-3">decrypt/3</a></h3>
<div class="spec">
<p><tt>decrypt(Key::&lt;&lt;_:256&gt;&gt;, AAD::binary(), Payload::binary()) -&gt; binary() | {error, failed_verification}</tt><br></p>
</div><p>Verifies the authenticity of the payload and decrypts the ciphertext
  generated by <a href="#encrypt-3"><code>encrypt/3</code></a>. Note the keys used as input to <a href="#encrypt-3"><code>encrypt/3</code></a>
  must be identical to those provided here. Decrypt is not responsible for
  decoding the underlying Swim protocol message -- see <a href="#decode-1"><code>decode/1</code></a>.</p>

<h3 class="function"><a name="encode_ack-3">encode_ack/3</a></h3>
<div class="spec">
<p><tt>encode_ack(Seq::<a href="#type-sequence">sequence()</a>, Target::<a href="#type-member">member()</a>, Events::[<a href="#type-swim_event">swim_event()</a>] | binary()) -&gt; binary() | no_return()</tt><br></p>
</div><p><p>Encodes an ACK message, piggybacking membership and user events.</p>
 
  An ACK message has the following format:
  <table border="1">
   <tr>
     <td>1</td>
     <td>4</td>
     <td>6</td>
     <td>N</td>
   </tr>
   <tr>
     <td>2</td>
     <td>Sequence</td>
     <td>Member</td>
     <td>Events</td>
   </tr>
  </table>
  <dl>
    <dt><strong><code>Sequence</code></strong></dt>
    <dd> is the the same Sequence received in the coorisponding PING message</dd>
    <dt><strong><code>Member</code></strong></dt>
    <dd> is the terminal Member for the coorisponding PING. In the case of
  a PING-REQ, the Member is not the sender of this ACK.
  See <a href="#encode_member-1"><code>encode_member/1</code></a> for Member encoding.</dd>
    <dt><strong><code>Events</code></strong></dt>
    <dd> is a list of membership and user events piggybacked as a part of the
  dissemination protocol.
  See <a href="#encode_events-1"><code>encode_events/1</code></a> for Event encoding.</dd>
  </dl></p>

<h3 class="function"><a name="encode_event-1">encode_event/1</a></h3>
<div class="spec">
<p><tt>encode_event(Event::<a href="#type-swim_event">swim_event()</a> | binary()) -&gt; binary()</tt><br></p>
</div><p><p>Encode either a membership event or a user event.</p>
 
  A membership event is encoded as follows:
  <table border="1">
   <tr>
     <td>1</td>
     <td>1</td>
     <td>6</td>
     <td>4</td>
   </tr>
   <tr>
     <td>50</td>
     <td>Status</td>
     <td>Member</td>
     <td>Incarnation</td>
   </tr>
  </table>
  <dl>
    <dt><strong><code>Status</code></strong></dt>
    <dd>is observered status of the Member being broadcast to the group</dd>
    <dt><strong><code>Member</code></strong></dt>
    <dd>is the subject of this membership event</dd>
    <dt><strong><code>Incarnation</code></strong></dt>
    <dd>is the incarnation of the subject Member known by the sender of this
  event. See <a href="swim_membership.html"><code>swim_membership</code></a> for more information on Incarncations.</dd>
  </dl>
 
  A user event is encoded as follows:
  <table border="1">
    <tr>
      <td>1</td>
      <td>2</td>
      <td>Size</td>
    </tr>
    <tr>
      <td>51</td>
      <td>Size</td>
      <td>Erlang Term</td>
    </tr>
  </table></p>

<h3 class="function"><a name="encode_events-1">encode_events/1</a></h3>
<div class="spec">
<p><tt>encode_events(Events::[<a href="#type-swim_event">swim_event()</a> | binary()]) -&gt; binary()</tt><br></p>
</div><p>Encodes a list of swim events. See <a href="#encode_event-1"><code>encode_event/1</code></a>.</p>

<h3 class="function"><a name="encode_leave-1">encode_leave/1</a></h3>
<div class="spec">
<p><tt>encode_leave(Seq::<a href="#type-sequence">sequence()</a>) -&gt; binary()</tt><br></p>
</div><p><p>Encodes a LEAVE message.</p>
 
  <table border="1">
   <tr>
     <td>1</td>
     <td>4</td>
   </tr>
   <tr>
     <td>4</td>
     <td>Sequence</td>
   </tr>
  </table>
  <dl>
    <dt><strong><code>Sequence</code></strong></dt>
    <dd>is the iteration of the failure detection protocol the leave message
  was sent during</dd>
  </dl></p>

<h3 class="function"><a name="encode_member-1">encode_member/1</a></h3>
<div class="spec">
<p><tt>encode_member(Member::{<a href="inet.html#type-ip_address">inet:ip_address()</a>, <a href="inet.html#type-port_number">inet:port_number()</a>}) -&gt; &lt;&lt;_:48&gt;&gt; | &lt;&lt;_:96&gt;&gt;</tt><br></p>
</div><p><p>Encodes a Member as the IPv4 address and port number combination.</p>
 
  <table border="1">
    <tr>
      <td>4</td>
      <td>2</td>
    </tr>
    <tr>
      <td>IPv4 Address</td>
      <td>Port Number</td>
    </tr>
  </table>
  <dl>
    <dt><strong><code>IPv4 Address</code></strong></dt>
    <dd>is the IPv4 Address the Member can be reached</dd>
    <dt><strong><code>Port Number</code></strong></dt>
    <dd>is the associated Port Number the Member is listening on</dd>
  </dl></p>

<h3 class="function"><a name="encode_ping-2">encode_ping/2</a></h3>
<div class="spec">
<p><tt>encode_ping(Seq::<a href="#type-sequence">sequence()</a>, Events::[<a href="#type-swim_event">swim_event()</a>] | binary()) -&gt; binary() | no_return()</tt><br></p>
</div><p><p>Encodes a PING message, piggybacking membership and user events.</p>
 
  A PING message has the following format:
  <table border="1">
    <tr>
      <td>1</td>
      <td>4</td>
      <td>N</td>
   </tr>
   <tr>
     <td>1</td>
     <td>Sequence</td>
     <td>Events</td>
   </tr>
  </table></p>

<h3 class="function"><a name="encode_ping_req-2">encode_ping_req/2</a></h3>
<div class="spec">
<p><tt>encode_ping_req(Seq::<a href="#type-sequence">sequence()</a>, Target::<a href="#type-member">member()</a>) -&gt; binary()</tt><br></p>
</div><p><p>Encodes a PING-REQ message.</p>
 
  A PING-REQ message has the following format:
  <table border="1">
    <tr>
      <td>1</td>
      <td>4</td>
      <td>6</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Sequence</td>
      <td>Member</td>
    </tr>
  </table>
  <dl>
   <dt><strong><code>Sequence</code></strong></dt>
   <dd> is the iteration of the failure detection protocol the PING-REQ was
  sent during</dd>
   <dt><strong><code>Member</code></strong></dt>
   <dd> the terminal of the PING-REQ. The receiver of the PING-REQ is the proxy
  for the PING. See <a href="#encode_member-1"><code>encode_member/1</code></a> for Member encoding.</dd>
  </dl></p>

<h3 class="function"><a name="encrypt-3">encrypt/3</a></h3>
<div class="spec">
<p><tt>encrypt(Key::&lt;&lt;_:256&gt;&gt;, AAD::binary(), PlainText::binary()) -&gt; binary()</tt><br></p>
</div><p>Encrypts the provided plain text using the Advanced Encryption Standard
  (AES) in Galois/Counter (GCM) using the provided 32-octet Key,
  Associated Authenticated Data (AAD), and a randomly generated
  Initialization Vector (IV). The resulting payload includes the 16-octet IV,
  the 16-octet CipherTag and the block encrypted cipher text.</p>

<h3 class="function"><a name="event_size_limit-0">event_size_limit/0</a></h3>
<div class="spec">
<p><tt>event_size_limit() -&gt; '?MAX_EVENT_SIZE'</tt><br></p>
</div><p><p>Event size limit determines the maximum size (in octets) available to       
to piggyback membership and user events on an ACK or PING message.</p>
 
  The max message size we use is the minimum reassembly buffer size defined for
  IPv4 to avoid IP fragmentation -- 576 octets.
  UDP has and overhead of a 20 octet IP header and an 8 octet
  UDP header. The max swim message size is 40 octets, with 16 octets for the
  nonce, and 16 octets for the CipherTag. That leaves 476 octets for the events.
  A membership event is 41 octets which equates to 11 membership events per
  ACK/PING message. User messages have an over head of 9 octets, leaving 467
  octets for the user message payload.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Jul 2 2015, 19:35:41.</i></p>
</body>
</html>
