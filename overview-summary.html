<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The swim application</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<h1>The swim application</h1>
<p>Copyright Â© 2015 Tucker Barbour</p>
<p><b>Version:</b> 0.0.1</p>
<p><b>Authors:</b> Tucker Barbour (<a href="mailto:barbct5@gmail.com"><tt>barbct5@gmail.com</tt></a>).</p>
<p><b>References</b><ul><li>http://www.cs.cornell.edu/~asdas/research/dsn02-SWIM.pdf</li></ul></p>
<h4><a name="Intro">Intro</a></h4>
     This Application is an Erlang implementation of the
     <i><b>S</b></i>calable <i><b>W</b></i>eakly-consistent <i><b>I</b></i>nfection-style
     Process Group <i><b>M</b></i>embership
     Protocol (SWIM). As the title implies, SWIM provides weakly-consistent
     knowledge of process group membership information to all participating
     processes. However, the <a href="http://erlangcentral.org/scalable-is-awesome-literally-garrett-smith-erlang-user-conference-2015/#.VZWtcXjEo22"><i>Scalable</i> part of the title should read:
     <i>Awesome!</i></a> So let's be more specific about what Awesome features SWIM provides:
     <ul>
       <li>Constant message load (bandwidth) per member regardless of the number
       of members in the group</li>
       <li>Constant time to first-detection of a faulty process regardless of
       the number of members in the group</li>
       <li>A deterministic time bound to detect failures</li>
       <li>Low false-positive failure detection rate</li>
     </ul>

     <h4><a name="Use_Cases">Use Cases</a></h4>
     What can we use SWIM for?
     <ul>
	<li>Reliable multicast</li>
	<li>Epidemic-style information dissemination</li>
	<li>Pub-sub</li>
	<li>Generic peer-to-peer systems</li>
     </ul><p>     
Really anything that requires us to maintain a list of members and detect     
when members join or leave the group, either voluntarily or through failure.</p>

     <h4><a name="Why?">Why?</a></h4><p>     
You may be thinking, "Why do we need the additional complexity of SWIM     
just to maintain a list of processes?" A popular approach you are probably already familiar with is to     
periodically send a message (heartbeat) to all the processes we know about and wait for a response.     
If we don't receive a response within some amount of time then we can call the process     
dead, either no longer running or unable to service requests. This has     
it's limitations as the number of members in the group increase. Sending     
heartbeats to all members leads to message load on the network that grows     
quadratically with the group size. If your group size is guarenteed to remain     
small, then this is a perfectly suitable solution. But what if our domain requires     
groups of processes in the order of thousands? Rather than sending heartbeats     
all other members what if we instead send our     
heartbeats along a logical ring of the group members? This approach may solve the message load problem but still has it's disadvantages.     
We still suffer from unpredictable failure detection time when there are multiple failures. Multiple     
failures may seem unlikely but as the size of the group grows so does the     
probability of failure. It would be nice if we had a protocol that     
provided constant message load and a predictable time-to-failure-detection     
as the size of the group grows. Oh wait, we do. SWIM.</p>

     <h4><a name="Why_Not?">Why Not?</a></h4>
     The biggest "Why Not?" is the weak-consistency guarentees of the protocol.
     If our domain requires consistent membership awareness, then we should look
     elsewhere:
     <ul>
	<li><a href="https://zookeeper.apache.org">Zookeeper</a></li>
	<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf">Paxos</a></li>
	<li><a href="https://www.usenix.org/conference/atc14/technical-sessions/presentation/ongaro">Raft</a></li>
	<li><a href="https://github.com/basho/riak_ensemble">Riak Ensemble</a></li>
     </ul>

     What if want more than just membership awareness and fault detection? Say
     we want some sort of application-level sharding like a consistent-hash ring?
     SWIM and this implemention only provide the features discussed in the SWIM
     paper. You can use SWIM as the underly gossip protocol to disseminate
     ring updates to the group -- but that's up to you and your application to do
     everything else. You may be better off taking a look at other, more specific, implementions like:
     <ul>
	<li><a href="https://github.com/uber/ringpop">Ringpop</a></li>
	<li><a href="https://github.com/helium/plumtree">Plumtree</a></li>
     </ul>

     What if the information we need to disseminate to the group is large, on
     the order of MiB and GiB? In
     this implementation of SWIM we strictly use UDP for transport and thus have an upper limit
     on the size of information we can move around. Again, we can use SWIM for membership
     awareness and write our application logic using TCP to transmit our large
     data between members -- up to you. It might also be worth taking a look at
     alternative implementations that have modified the protocol to support both UDP and TCP:
     <ul>
	<li><a href="https://github.com/hashicorp/memberlist">Memberlist</a></li>
     </ul>

     <h4><a name="Details">Details</a></h4>
     If you made it this far and are still interested, you should read the module
     documentation which includes details about the implementation. I also highly
     recommend reading the SWIM paper referenced at the top of the documentation.
     The pieces of the SWIM protocol are broken down as follows:
     <dl>
          <dt><strong><code>Failure Detection</code></strong></dt>
     	  <dd><a href="swim_gossip.html"><code>swim_gossip</code></a></dd>
	  <dt><strong><code>Membership</code></strong></dt>
     	  <dd><strong><code><a href="swim_membership.html"><code>swim_membership</code></a></code></strong></dd>
     	  <dt><strong><code>Dissemination</code></strong></dt>
     	  <dd><a href="swim_broadcasts.html"><code>swim_broadcasts</code></a></dd>
     </dl>

     <h4><a name="How_To">How To</a></h4><p>
     Here is a quick reference for using SWIM in your application. These examples
     assume the <code>swim</code> and <code>crypto</code> applications are already started. We also     
assume encryption keys have already been distributed -- that's outside the     
scope of SWIM.</p>

    <pre>	% On our first node, let's start the seed listening at 192.168.2.10:5000
	ok = swim:start_gossip(lan, {192,168,2,10}, 5000, [{keys, Keys}])

	% On a different node, let's join the group 'lan' using 192.168.2.10:5000
	% as the seed.
	Seeds = [{{192,168,2,10}, 5000}],
	ok = swim:start_gossip(lan, {192,168,2,11}, 5000, [{seeds, Seeds},
	     			    		    	   {keys, Keys}]),
	% Let's check who else is in the group
	swim:members(lan)</pre>

<hr>
<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Jul 2 2015, 19:35:41.</i></p>
</body>
</html>
