

# Module swim_messages #
* [Description](#description)
* [Function Index](#index)
* [Function Details](#functions)

This module is responsible for encoding and decoding SWIM protocol
messages as well as encrypting and decrypting the message payloads.

Copyright (c) 2015

__Version:__ Feb 18 2016 00:10:58

<a name="description"></a>

## Description ##

SWIM protocol message encodings can be found in the documentation
cooresponding to the various encoding functions defined in this module.
[`encode_ack/3`](#encode_ack-3), [`encode_ping/2`](#encode_ping-2), [`encode_ping_req/2`](#encode_ping_req-2),
[`encode_leave/1`](#encode_leave-1).
All SWIM protocol messages are prefixed with a single octet reflecting
the protocol version of the message. The overall format of SWIM messages is:


<table border="1">
<tr>
<td>1</td>
<td>1</td>
<td>N</td>
</tr>
<tr>
<td>Version</td>
<td>Tag</td>
<td>Data</td>
</tr>
</table>


- __*Version*__ : is the protocol version the message is encoded for
- __*Tag*__ : indicates what type of SWIM message Data represents; ACK, PING,
PING-REG, or LEAVE
- __*Data*__ : The SWIM messages payload

All SWIM messages are encrypted over the wire using AES128-GCM. See
[`encrypt/3`](#encrypt-3) for more information. The encryption header is encoded as
follows:


<table border="1">
<tr>
<td>16</td>
<td>16</td>
<td>N</td>
</tr>
<tr>
<td>IV</td>
<td>CipherTag</td>
<td>CipherText</td>
</tr>
</table>

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#decode-1">decode/1</a></td><td>Decodes the provided message from a binary to an Erlang Term.</td></tr><tr><td valign="top"><a href="#decode_event-2">decode_event/2</a></td><td></td></tr><tr><td valign="top"><a href="#decode_events-1">decode_events/1</a></td><td></td></tr><tr><td valign="top"><a href="#decrypt-3">decrypt/3</a></td><td>Verifies the authenticity of the payload and decrypts the ciphertext
generated by <a href="#encrypt-3"><code>encrypt/3</code></a>.</td></tr><tr><td valign="top"><a href="#encode_ack-3">encode_ack/3</a></td><td>Encodes an ACK message, piggybacking membership and user events.</td></tr><tr><td valign="top"><a href="#encode_event-1">encode_event/1</a></td><td>Encode either a membership event or a user event.</td></tr><tr><td valign="top"><a href="#encode_events-1">encode_events/1</a></td><td>Encodes a list of swim events.</td></tr><tr><td valign="top"><a href="#encode_leave-1">encode_leave/1</a></td><td>Encodes a LEAVE message.</td></tr><tr><td valign="top"><a href="#encode_member-1">encode_member/1</a></td><td>Encodes a Member as the IP address and port number combination.</td></tr><tr><td valign="top"><a href="#encode_ping-2">encode_ping/2</a></td><td>Encodes a PING message, piggybacking membership and user events.</td></tr><tr><td valign="top"><a href="#encode_ping_req-2">encode_ping_req/2</a></td><td>Encodes a PING-REQ message.</td></tr><tr><td valign="top"><a href="#encrypt-3">encrypt/3</a></td><td>Encrypts the provided plain text using the Advanced Encryption Standard
(AES) in Galois/Counter (GCM) using the provided 32-octet Key,
Associated Authenticated Data (AAD), and a randomly generated
Initialization Vector (IV).</td></tr><tr><td valign="top"><a href="#event_size_limit-0">event_size_limit/0</a></td><td>Event size limit determines the maximum size (in octets) available to
to piggyback membership and user events on an ACK or PING message.</td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="decode-1"></a>

### decode/1 ###

<pre><code>
decode(Message::binary()) -&gt; <a href="#type-swim_message">swim_message()</a>
</code></pre>
<br />

Decodes the provided message from a binary to an Erlang Term.

All messages are prefixed with a single octet to indicate the version of
of the protocol. The return value is an Erlang term of the message. If the
version is not supported or the message is malformed, an exception is thrown.

<a name="decode_event-2"></a>

### decode_event/2 ###

<pre><code>
decode_event(X1::membership | user, X2::binary()) -&gt; {<a href="#type-swim_event">swim_event()</a>, binary()}
</code></pre>
<br />

<a name="decode_events-1"></a>

### decode_events/1 ###

<pre><code>
decode_events(Events::binary()) -&gt; [<a href="#type-swim_event">swim_event()</a>]
</code></pre>
<br />

<a name="decrypt-3"></a>

### decrypt/3 ###

<pre><code>
decrypt(Key::&lt;&lt;_:256&gt;&gt;, AAD::binary(), Payload::binary()) -&gt; binary() | {error, failed_verification}
</code></pre>
<br />

Verifies the authenticity of the payload and decrypts the ciphertext
generated by [`encrypt/3`](#encrypt-3). Note the keys used as input to [`encrypt/3`](#encrypt-3)
must be identical to those provided here. Decrypt is not responsible for
decoding the underlying Swim protocol message -- see [`decode/1`](#decode-1).

<a name="encode_ack-3"></a>

### encode_ack/3 ###

<pre><code>
encode_ack(Seq::<a href="#type-sequence">sequence()</a>, Target::<a href="#type-member">member()</a>, Events::[<a href="#type-swim_event">swim_event()</a>] | binary()) -&gt; binary() | no_return()
</code></pre>
<br />

Encodes an ACK message, piggybacking membership and user events.

An ACK message has the following format:


<table border="1">
<tr>
<td>1</td>
<td>4</td>
<td>6</td>
<td>N</td>
</tr>
<tr>
<td>2</td>
<td>Sequence</td>
<td>Member</td>
<td>Events</td>
</tr>
</table>





<dt><strong><code>Sequence</code></strong></dt>




<dd> is the the same Sequence received in the coorisponding PING message</dd>




<dt><strong><code>Member</code></strong></dt>




<dd> is the terminal Member for the coorisponding PING. In the case of
a PING-REQ, the Member is not the sender of this ACK.
See <a href="#encode_member-1"><code>encode_member/1</code></a> for Member encoding.</dd>




<dt><strong><code>Events</code></strong></dt>




<dd> is a list of membership and user events piggybacked as a part of the
dissemination protocol.
See <a href="#encode_events-1"><code>encode_events/1</code></a> for Event encoding.</dd>



<a name="encode_event-1"></a>

### encode_event/1 ###

<pre><code>
encode_event(Event::<a href="#type-swim_event">swim_event()</a> | binary()) -&gt; binary()
</code></pre>
<br />

Encode either a membership event or a user event.

A membership event is encoded as follows:


<table border="1">
<tr>
<td>1</td>
<td>1</td>
<td>6</td>
<td>4</td>
</tr>
<tr>
<td>50</td>
<td>Status</td>
<td>Member</td>
<td>Incarnation</td>
</tr>
</table>





<dt><strong><code>Status</code></strong></dt>




<dd>is observed status of the Member being broadcast to the group</dd>




<dt><strong><code>Member</code></strong></dt>




<dd>is the subject of this membership event</dd>




<dt><strong><code>Incarnation</code></strong></dt>




<dd>is the incarnation of the subject Member known by the sender of this
event. See <a href="swim_membership.md"><code>swim_membership</code></a> for more information on Incarnations.</dd>



A user event is encoded as follows:


<table border="1">
<tr>
<td>1</td>
<td>2</td>
<td>Size</td>
</tr>
<tr>
<td>51</td>
<td>Size</td>
<td>Erlang Term</td>
</tr>
</table>


<a name="encode_events-1"></a>

### encode_events/1 ###

<pre><code>
encode_events(Events::[<a href="#type-swim_event">swim_event()</a> | binary()]) -&gt; binary()
</code></pre>
<br />

Encodes a list of swim events. See [`encode_event/1`](#encode_event-1).

<a name="encode_leave-1"></a>

### encode_leave/1 ###

<pre><code>
encode_leave(Seq::<a href="#type-sequence">sequence()</a>) -&gt; binary()
</code></pre>
<br />

Encodes a LEAVE message.


<table border="1">
<tr>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>Sequence</td>
</tr>
</table>





<dt><strong><code>Sequence</code></strong></dt>




<dd>is the iteration of the failure detection protocol the leave message
was sent during</dd>



<a name="encode_member-1"></a>

### encode_member/1 ###

<pre><code>
encode_member(Member::{<a href="inet.md#type-ip_address">inet:ip_address()</a>, <a href="inet.md#type-port_number">inet:port_number()</a>}) -&gt; &lt;&lt;_:48&gt;&gt; | &lt;&lt;_:96&gt;&gt;
</code></pre>
<br />

Encodes a Member as the IP address and port number combination.


<table border="1">
<tr>
<td>1</td>
<td>Size</td>
<td>2</td>
</tr>
<tr>
<td>Size</td>
<td>IP Address</td>
<td>Port Number</td>
</tr>
</table>





<dt><strong><code>IP Address</code></strong></dt>




<dd>is the IPv4 or IPv6 address the Member can be reached</dd>




<dt><strong><code>Port Number</code></strong></dt>




<dd>is the associated Port Number the Member is listening on</dd>



<a name="encode_ping-2"></a>

### encode_ping/2 ###

<pre><code>
encode_ping(Seq::<a href="#type-sequence">sequence()</a>, Events::[<a href="#type-swim_event">swim_event()</a>] | binary()) -&gt; binary() | no_return()
</code></pre>
<br />

Encodes a PING message, piggybacking membership and user events.

A PING message has the following format:


<table border="1">
<tr>
<td>1</td>
<td>4</td>
<td>N</td>
</tr>
<tr>
<td>1</td>
<td>Sequence</td>
<td>Events</td>
</tr>
</table>


<a name="encode_ping_req-2"></a>

### encode_ping_req/2 ###

<pre><code>
encode_ping_req(Seq::<a href="#type-sequence">sequence()</a>, Target::<a href="#type-member">member()</a>) -&gt; binary()
</code></pre>
<br />

Encodes a PING-REQ message.

A PING-REQ message has the following format:


<table border="1">
<tr>
<td>1</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>Sequence</td>
<td>Member</td>
</tr>
</table>





<dt><strong><code>Sequence</code></strong></dt>




<dd> is the iteration of the failure detection protocol the PING-REQ was
sent during</dd>




<dt><strong><code>Member</code></strong></dt>




<dd> the terminal of the PING-REQ. The receiver of the PING-REQ is the proxy
for the PING. See <a href="#encode_member-1"><code>encode_member/1</code></a> for Member encoding.</dd>



<a name="encrypt-3"></a>

### encrypt/3 ###

<pre><code>
encrypt(Key::&lt;&lt;_:256&gt;&gt;, AAD::binary(), PlainText::binary()) -&gt; binary()
</code></pre>
<br />

Encrypts the provided plain text using the Advanced Encryption Standard
(AES) in Galois/Counter (GCM) using the provided 32-octet Key,
Associated Authenticated Data (AAD), and a randomly generated
Initialization Vector (IV). The resulting payload includes the 16-octet IV,
the 16-octet CipherTag and the block encrypted cipher text.

<a name="event_size_limit-0"></a>

### event_size_limit/0 ###

<pre><code>
event_size_limit() -&gt; '?MAX_EVENT_SIZE'
</code></pre>
<br />

Event size limit determines the maximum size (in octets) available to
to piggyback membership and user events on an ACK or PING message.

The max message size we use is the minimum reassembly buffer size defined for
IPv4 to avoid IP fragmentation -- 576 octets.
UDP has and overhead of a 20 octet IP header and an 8 octet
UDP header. The max swim message size is 40 octets, with 16 octets for the
nonce, and 16 octets for the CipherTag. That leaves 476 octets for the events.
A membership event is 41 octets which equates to 11 membership events per
ACK/PING message. User messages have an over head of 9 octets, leaving 467
octets for the user message payload.

